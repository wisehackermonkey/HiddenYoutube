<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube Hidden Video Search Generator</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }
        
        .container { 
            max-width: 1400px; 
            margin: 0 auto; 
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }
        
        h1 {
            text-align: center;
            font-size: 2.5em;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 40px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .controls { 
            background: #f8f9fa;
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .control-row {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        select, input, button { 
            padding: 12px 18px;
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            background: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        
        select:focus, input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            transform: translateY(-1px);
        }
        
        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
            overflow: hidden;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }
        
        button:hover::before {
            left: 100%;
        }
        
        #patternSelect {
            flex: 2;
            min-width: 250px;
        }
        
        #regexInput {
            flex: 1;
            min-width: 200px;
            font-family: 'Courier New', monospace;
        }
        
        .control-row.center {
            justify-content: center;
        }
        
        .search-btn {
            font-size: 18px;
            padding: 18px 40px;
            background: linear-gradient(135deg, #28a745, #20c997);
            box-shadow: 0 6px 20px rgba(40, 167, 69, 0.3);
            border-radius: 15px;
            text-transform: uppercase;
            font-weight: 700;
            letter-spacing: 1px;
        }
        
        .search-btn:hover {
            background: linear-gradient(135deg, #20c997, #28a745);
            box-shadow: 0 10px 30px rgba(40, 167, 69, 0.4);
            transform: translateY(-3px);
        }
        
        .current-search-small {
            font-size: 12px;
            color: #666;
            font-weight: normal;
            flex: 1;
            display: flex;
            align-items: center;
        }
        
        .current-search-small span {
            font-family: 'Courier New', monospace;
            background: #f8f9fa;
            padding: 3px 8px;
            border-radius: 4px;
            margin-left: 8px;
            font-size: 11px;
        }
        
        #output { 
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            padding: 20px;
            margin: 20px 0;
            border-radius: 12px;
            min-height: 60px;
            word-break: break-all;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            font-weight: 600;
            border: 2px solid #e1e5e9;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        
        .error { 
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
            color: white;
            border-color: #ff4757;
        }
        
        .video-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); 
            gap: 25px; 
            margin-top: 30px; 
        }
        
        .video-item { 
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
        }
        
        .video-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.15);
        }
        
        .video-title { 
            font-weight: 700;
            margin: 15px 0 8px 0;
            font-size: 16px;
            color: #2c3e50;
            line-height: 1.4;
        }
        
        .video-views { 
            color: #6c757d;
            font-size: 13px;
            font-weight: 500;
        }
        
        iframe { 
            width: 100%; 
            height: 220px;
            border-radius: 10px;
            border: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .loading { 
            text-align: center;
            padding: 40px;
            font-size: 18px;
            font-weight: 600;
            color: #667eea;
        }
        
        .loading::after {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 20px;
                margin: 10px;
            }
            
            .control-row {
                flex-direction: column;
            }
            
            select, input, button {
                width: 100%;
            }
            
            .video-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
        }
        
        /* Glassmorphism effect for better visual appeal */
        .controls::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            border-radius: 15px;
            z-index: -1;
        }
        
        .controls {
            position: relative;
        }
        
        .description {
            text-align: center;
            margin-bottom: 30px;
            padding: 25px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        
        .description p {
            margin-bottom: 15px;
            line-height: 1.6;
            color: #555;
        }
        
        .description p:last-child {
            margin-bottom: 0;
        }
        
        .dev-note {
            font-size: 0.85em;
            color: #777;
            font-style: italic;
        }
        
        .dev-note a {
            color: #667eea;
            text-decoration: none;
        }
        
        .dev-note a:hover {
            text-decoration: underline;
        }
        
        .credits {
            margin-top: 50px;
            padding: 30px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        
        .credits h3 {
            font-size: 1.5em;
            margin-bottom: 20px;
            color: #2c3e50;
            text-align: center;
        }
        
        .credits p {
            margin-bottom: 15px;
            line-height: 1.6;
            color: #555;
        }
        
        .credits a {
            color: #667eea;
            text-decoration: none;
            font-weight: 600;
            transition: color 0.3s ease;
        }
        
        .credits a:hover {
            color: #764ba2;
            text-decoration: underline;
        }
        
        .original-image {
            text-align: center;
            margin-top: 25px;
            padding-top: 25px;
            border-top: 2px solid #e1e5e9;
        }
        
        .original-image p {
            margin-bottom: 15px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .original-image img {
            max-width: 300px;
            width: 100%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            transition: transform 0.3s ease;
        }
        
        .original-image img:hover {
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>YouTube Hidden Video Search Generator</h1>
        
        <div class="description">
            <p>Want to discover rare, unseen videos on YouTube untouched by the algorithm? This tool generates random video titles that often lead to hidden gems!</p>
            <p><strong>How to use:</strong> Select a pattern (we recommend starting with "IMG XXXX"), click "Generate", then "Search YouTube". If nothing interesting appears, generate again!</p>
            <p class="dev-note">For developers: The input box uses a modified regex format for generating search terms. <a href="https://fent.github.io/randexp.js/" target="_blank">Learn more here</a>.</p>
        </div>
        
        <div class="controls">
            <div class="control-row">
                <select id="patternSelect" onchange="selectPattern()">
                    <option value="">Select a pattern...</option>
                    <option value="/[A-Z]{3}\d{3}/">Example pattern</option>
                    <option value="/IMG \d{4}/">IMG XXXX</option>
                    <option value="/MVI \d{4}/">MVI XXXX</option>
                    <option value="/MOV \d{4}/">MOV XXXX</option>
                    <option value="/VID 20\d{2}\d{2}/">VID (YMD)</option>
                    <option value="/WIN 20\d{2}\d{2}/">WIN (YMD)</option>
                    <option value="/Capture 20\d{2}\d{2}/">Capture (YMD)</option>
                    <option value="/My Movie/">My Movie</option>
                    <option value="/My Edited Video/">My Edited Video</option>
                    <option value="/Screenshot\/Emulated\//">Screenshot/Emulated/</option>
                    <option value="/PXL/">PXL</option>
                    <option value="/InShot_20\d{2}\d{2}/">InShot_(YMD)_</option>
                    <option value="/WhatsApp Video \d{4}/">WhatsApp Video (Y)</option>
                    <option value="/FullSizeRender/">FullSizeRender</option>
                    <option value="/RFReplay/">RFReplay</option>
                    <option value="/VTS \d{2}/">VTS 01</option>
                    <option value="/DVR/">DVR</option>
                    <option value="/SWF/">SWF</option>
                    <option value="/VLC Record/">VLC Record</option>
                    <option value="/Robloxapp/">Robloxapp</option>
                    <option value="/MP4/">MP4</option>
                    <option value="/3GP/">3GP</option>
                    <option value="/MOV/">MOV</option>
                    <option value="/AVI/">AVI</option>
                    <option value="/WMV/">WMV</option>
                    <option value="/MKV/">MKV</option>
                    <option value="/MPEG/">MPEG</option>
                    <option value="/FLV/">FLV</option>
                    <option value="/FLAC/">FLAC</option>
                    <option value="/WAV/">WAV</option>
                    <option value="/\d{3}P \d{3}K/">240P 400K</option>
                    <option value="/\d{3}P \d{3}K/">480P 100K</option>
                    <option value="/\d{3}P \d{3}K [A-Z]/">480P 600K A</option>
                    <option value="/\d{3}P \d{4}K [A-Z]/">480P 2000K A</option>
                    <option value="/\d{3}P \d{4}K [A-Z]/">720P 1500K A</option>
                    <option value="/\d{3}P \d{4}K [A-Z]/">720P 4000K A</option>
                    <option value="/InShot 20\d{2}/">InShot (YMD)</option>
                    <option value="/AUD-20\d{2}/">AUD-(YMD)</option>
                    <option value="/PXL D-20\d{2}/">PXL (YMD) D-</option>
                    <option value="/HNI \d{4}/">HNI 0XXX</option>
                    <option value="/WAD \d{3}/">WAD XXX</option>
                    <option value="/MOLO [A-Z]{2}/">MOLO XX</option>
                    <option value="/MOLO \d{2}/">MOLO XX</option>
                    <option value="/[A-Z]{3} \d{6}/">UTS XXX</option>
                    <option value="/P10 \d{4}/">P10 XXXX</option>
                    <option value="/VTS [A-Z]{2}/">VTS XX</option>
                    <option value="/VO \d/">VO 0-9</option>
                    <option value="/VTS [A-Z]{3} 1/">VTS XXX 1</option>
                    <option value="/VTS \d{2} [A-Z]{3}/">VTS 01 XXX</option>
                    <option value="/My Slideshow/">My Slideshow</option>
                    <option value="/My Slideshow [A-Z]{2}/">My Slideshow XX</option>
                    <option value="/My Slideshow Video/">My Slideshow Video</option>
                    <option value="/My Superflix Video/">My Superflix Video</option>
                    <option value="/My Superflix Video [A-Z]{4}/">My Superflix Video XXXX</option>
                </select>
                
                <input type="text" id="regexInput" placeholder="/[A-Z]{3}\d{3}/" value="/[A-Z]{3}\d{3}/">
                <button onclick="generate()">Generate</button>
            </div>
            
            <div class="control-row center">
                <button class="search-btn" onclick="searchVideos()">Search YouTube</button>
            </div>
            
            <div class="control-row">
                <select id="viewFilter">
                    <option value="">All videos</option>
                    <option value="0">No views</option>
                    <option value="5000">Under 5k views</option>
                </select>
                
                <div class="current-search-small">Current search: <span id="currentSearch"></span></div>
            </div>
        </div>

        <div id="output"></div>
        <div class="video-grid" id="videoGrid"></div>
        <div class="loading" id="loading" style="display: none;">Loading videos...</div>
        
        <div class="credits">
            <h3>Credits</h3>
            <p>Code created by <strong>Oran Collins</strong> aka <a href="https://github.com/wisehackermonkey" target="_blank">wisehackermonkey on GitHub</a></p>
            <p>I'd like to thank <strong>KVN AUST</strong> for the awesome patterns, all credit for patterns go to him, go subscribe to his channel <a href="https://www.youtube.com/@KVNAUST" target="_blank">HERE</a></p>
            <p><strong>KVN AUST:</strong> <a href="https://www.youtube.com/@KVNAUST" target="_blank">https://www.youtube.com/@KVNAUST</a></p>
            
            <div class="original-image">
                <p>Here's the original patterns image which I used for this website:</p>
                <img src="static/youtube_recyclebin.jpeg" alt="Original YouTube patterns reference" />
            </div>
        </div>
    </div>

    <script>
        let currentSearch = '';
        let allVideos = [];

// Simple DRange implementation (Discontinuous Range)
class DRange {
    constructor(start, end) {
        this.ranges = [];
        if (arguments.length === 1) {
            this.add(start);
        } else if (arguments.length === 2) {
            this.add(start, end);
        }
    }
    
    add(start, end) {
        if (typeof start === 'object' && start instanceof DRange) {
            // Adding another DRange
            for (let range of start.ranges) {
                this.add(range.start, range.end);
            }
        } else if (end === undefined) {
            // Single number
            this.ranges.push({ start: start, end: start });
        } else {
            // Range
            this.ranges.push({ start: start, end: end });
        }
        this._normalize();
        return this;
    }
    
    subtract(other) {
        let result = new DRange();
        for (let range of this.ranges) {
            let current = [range];
            for (let otherRange of other.ranges) {
                let next = [];
                for (let curr of current) {
                    if (curr.end < otherRange.start || curr.start > otherRange.end) {
                        next.push(curr);
                    } else {
                        if (curr.start < otherRange.start) {
                            next.push({ start: curr.start, end: otherRange.start - 1 });
                        }
                        if (curr.end > otherRange.end) {
                            next.push({ start: otherRange.end + 1, end: curr.end });
                        }
                    }
                }
                current = next;
            }
            for (let r of current) {
                result.ranges.push(r);
            }
        }
        result._normalize();
        return result;
    }
    
    intersect(other) {
        let result = new DRange();
        for (let range of this.ranges) {
            for (let otherRange of other.ranges) {
                let start = Math.max(range.start, otherRange.start);
                let end = Math.min(range.end, otherRange.end);
                if (start <= end) {
                    result.add(start, end);
                }
            }
        }
        return result;
    }
    
    clone() {
        let result = new DRange();
        result.ranges = this.ranges.map(r => ({ start: r.start, end: r.end }));
        return result;
    }
    
    get length() {
        return this.ranges.reduce((sum, range) => sum + (range.end - range.start + 1), 0);
    }
    
    index(i) {
        for (let range of this.ranges) {
            let rangeSize = range.end - range.start + 1;
            if (i < rangeSize) {
                return range.start + i;
            }
            i -= rangeSize;
        }
        throw new Error('Index out of range');
    }
    
    _normalize() {
        this.ranges.sort((a, b) => a.start - b.start);
        let normalized = [];
        for (let range of this.ranges) {
            if (normalized.length === 0) {
                normalized.push(range);
            } else {
                let last = normalized[normalized.length - 1];
                if (range.start <= last.end + 1) {
                    last.end = Math.max(last.end, range.end);
                } else {
                    normalized.push(range);
                }
            }
        }
        this.ranges = normalized;
    }
}

// Simple ret (regexp tree) implementation
const ret = (function() {
    const types = {
        ROOT: 0,
        GROUP: 1,
        POSITION: 2,
        SET: 3,
        REPETITION: 4,
        REFERENCE: 5,
        CHAR: 6,
        RANGE: 7
    };

    function parse(regexp) {
        let pos = 0;
        let len = regexp.length;
        
        function parseGroup() {
            let node = { type: types.GROUP, stack: [] };
            
            while (pos < len && regexp[pos] !== ')') {
                node.stack.push(parseToken());
            }
            
            if (pos < len && regexp[pos] === ')') pos++;
            return node;
        }
        
        function parseSet() {
            let node = { type: types.SET, set: [], not: false };
            
            if (pos < len && regexp[pos] === '^') {
                node.not = true;
                pos++;
            }
            
            while (pos < len && regexp[pos] !== ']') {
                if (pos + 2 < len && regexp[pos + 1] === '-') {
                    node.set.push({
                        type: types.RANGE,
                        from: regexp.charCodeAt(pos),
                        to: regexp.charCodeAt(pos + 2)
                    });
                    pos += 3;
                } else {
                    node.set.push({
                        type: types.CHAR,
                        value: regexp.charCodeAt(pos)
                    });
                    pos++;
                }
            }
            
            if (pos < len && regexp[pos] === ']') pos++;
            return node;
        }
        
        function parseToken() {
            let node;
            
            if (pos >= len) return null;
            
            let char = regexp[pos];
            
            switch (char) {
                case '(':
                    pos++;
                    node = parseGroup();
                    break;
                case '[':
                    pos++;
                    node = parseSet();
                    break;
                case '\\':
                    pos++;
                    if (pos < len) {
                        let escaped = regexp[pos];
                        if (escaped === 'd') {
                            node = {
                                type: types.SET,
                                set: [{ type: types.RANGE, from: 48, to: 57 }],
                                not: false
                            };
                        } else if (escaped === 'w') {
                            node = {
                                type: types.SET,
                                set: [
                                    { type: types.RANGE, from: 48, to: 57 },
                                    { type: types.RANGE, from: 65, to: 90 },
                                    { type: types.RANGE, from: 97, to: 122 },
                                    { type: types.CHAR, value: 95 }
                                ],
                                not: false
                            };
                        } else if (escaped === 's') {
                            node = {
                                type: types.SET,
                                set: [
                                    { type: types.CHAR, value: 32 },
                                    { type: types.CHAR, value: 9 },
                                    { type: types.CHAR, value: 10 },
                                    { type: types.CHAR, value: 13 }
                                ],
                                not: false
                            };
                        } else {
                            node = { type: types.CHAR, value: escaped.charCodeAt(0) };
                        }
                        pos++;
                    }
                    break;
                default:
                    node = { type: types.CHAR, value: char.charCodeAt(0) };
                    pos++;
                    break;
            }
            
            // Check for repetition
            if (pos < len) {
                let next = regexp[pos];
                if (next === '*') {
                    node = { type: types.REPETITION, min: 0, max: Infinity, value: node };
                    pos++;
                } else if (next === '+') {
                    node = { type: types.REPETITION, min: 1, max: Infinity, value: node };
                    pos++;
                } else if (next === '?') {
                    node = { type: types.REPETITION, min: 0, max: 1, value: node };
                    pos++;
                } else if (next === '{') {
                    pos++;
                    let min = '';
                    while (pos < len && /\d/.test(regexp[pos])) {
                        min += regexp[pos];
                        pos++;
                    }
                    let max = min;
                    if (pos < len && regexp[pos] === ',') {
                        pos++;
                        max = '';
                        while (pos < len && /\d/.test(regexp[pos])) {
                            max += regexp[pos];
                            pos++;
                        }
                        if (max === '') max = 'Infinity';
                    }
                    if (pos < len && regexp[pos] === '}') {
                        pos++;
                        node = {
                            type: types.REPETITION,
                            min: parseInt(min) || 0,
                            max: max === 'Infinity' ? Infinity : parseInt(max),
                            value: node
                        };
                    }
                }
            }
            
            return node;
        }
        
        let tokens = { type: types.ROOT, stack: [] };
        while (pos < len) {
            let token = parseToken();
            if (token) tokens.stack.push(token);
        }
        
        return tokens;
    }
    
    return function(regexp) {
        return parse(regexp);
    };
})();

ret.types = {
    ROOT: 0,
    GROUP: 1,
    POSITION: 2,
    SET: 3,
    REPETITION: 4,
    REFERENCE: 5,
    CHAR: 6,
    RANGE: 7
};

// RandExp class (adapted for browser)
class RandExp {
    constructor(regexp, m) {
        this._setDefaults(regexp);
        if (regexp instanceof RegExp) {
            this.ignoreCase = regexp.ignoreCase;
            this.multiline = regexp.multiline;
            regexp = regexp.source;
        } else if (typeof regexp === 'string') {
            this.ignoreCase = m && m.indexOf('i') !== -1;
            this.multiline = m && m.indexOf('m') !== -1;
        } else {
            throw new Error('Expected a regexp or string');
        }

        this.tokens = ret(regexp);
    }

    _setDefaults(regexp) {
        this.max = regexp.max != null ? regexp.max :
            RandExp.prototype.max != null ? RandExp.prototype.max : 100;

        this.defaultRange = regexp.defaultRange ?
            regexp.defaultRange : this.defaultRange.clone();

        if (regexp.randInt) {
            this.randInt = regexp.randInt;
        }
    }

    gen() {
        return this._gen(this.tokens, []);
    }

    _gen(token, groups) {
        var stack, str, n, i, l;

        switch (token.type) {
            case ret.types.ROOT:
            case ret.types.GROUP:
                if (token.followedBy || token.notFollowedBy) { return ''; }

                if (token.remember && token.groupNumber === undefined) {
                    token.groupNumber = groups.push(null) - 1;
                }

                stack = token.options ?
                    this._randSelect(token.options) : token.stack;

                str = '';
                for (i = 0, l = stack.length; i < l; i++) {
                    str += this._gen(stack[i], groups);
                }

                if (token.remember) {
                    groups[token.groupNumber] = str;
                }
                return str;

            case ret.types.POSITION:
                return '';

            case ret.types.SET:
                var expandedSet = this._expand(token);
                if (!expandedSet.length) { return ''; }
                return String.fromCharCode(this._randSelect(expandedSet));

            case ret.types.REPETITION:
                n = this.randInt(token.min,
                    token.max === Infinity ? token.min + this.max : token.max);

                str = '';
                for (i = 0; i < n; i++) {
                    str += this._gen(token.value, groups);
                }

                return str;

            case ret.types.REFERENCE:
                return groups[token.value - 1] || '';

            case ret.types.CHAR:
                var code = this.ignoreCase && this._randBool() ?
                    this._toOtherCase(token.value) : token.value;
                return String.fromCharCode(code);
        }
    }

    _toOtherCase(code) {
        return code + (97 <= code && code <= 122 ? -32 :
            65 <= code && code <= 90 ? 32 : 0);
    }

    _randBool() {
        return !this.randInt(0, 1);
    }

    _randSelect(arr) {
        if (arr instanceof DRange) {
            return arr.index(this.randInt(0, arr.length - 1));
        }
        return arr[this.randInt(0, arr.length - 1)];
    }

    _expand(token) {
        if (token.type === ret.types.CHAR) {
            return new DRange(token.value);
        } else if (token.type === ret.types.RANGE) {
            return new DRange(token.from, token.to);
        } else {
            let drange = new DRange();
            for (let i = 0; i < token.set.length; i++) {
                let subrange = this._expand(token.set[i]);
                drange.add(subrange);
                if (this.ignoreCase) {
                    for (let j = 0; j < subrange.length; j++) {
                        let code = subrange.index(j);
                        let otherCaseCode = this._toOtherCase(code);
                        if (code !== otherCaseCode) {
                            drange.add(otherCaseCode);
                        }
                    }
                }
            }
            if (token.not) {
                return this.defaultRange.clone().subtract(drange);
            } else {
                return this.defaultRange.clone().intersect(drange);
            }
        }
    }

    randInt(a, b) {
        return a + Math.floor(Math.random() * (1 + b - a));
    }

    get defaultRange() {
        return this._range = this._range || new DRange(32, 126);
    }

    set defaultRange(range) {
        this._range = range;
    }
}

function selectPattern() {
    const select = document.getElementById('patternSelect');
    const input = document.getElementById('regexInput');
    if (select.value) {
        input.value = select.value;
    }
}

function generate() {
    const input = document.getElementById('regexInput').value;
    const output = document.getElementById('output');
    
    try {
        let regexString = input.trim();
        if (regexString.startsWith('/') && regexString.endsWith('/')) {
            regexString = regexString.slice(1, -1);
        }
        
        const randexp = new RandExp(regexString);
        const result = randexp.gen();
        
        output.textContent = result;
        output.className = '';
        
        currentSearch = result;
        document.getElementById('currentSearch').textContent = currentSearch;
    } catch (error) {
        output.textContent = 'Error: ' + error.message;
        output.className = 'error';
    }
}

async function searchVideos() {
    if (!currentSearch) return;

    document.getElementById('loading').style.display = 'block';
    document.getElementById('videoGrid').innerHTML = '';

    try {
        const response = await fetch('/api/search', {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                query: currentSearch
            })
        });

        const data = await response.json();
        allVideos = data.videos;
        displayVideos(allVideos);

    } catch (error) {
        allVideos = generateMockVideos();
        displayVideos(allVideos);
    }

    document.getElementById('loading').style.display = 'none';
}

function generateMockVideos() {
    const mockVideos = [];
    for (let i = 0; i < 15; i++) {
        const viewCount = Math.random() < 0.3 ? 0 : Math.floor(Math.random() * 10000);
        mockVideos.push({
            id: generateVideoId(),
            title: currentSearch + (Math.random() > 0.7 ? ` (${Math.floor(Math.random() * 100)})` : ''),
            viewCount: viewCount,
            channelName: `User${Math.floor(Math.random() * 10000)}`
        });
    }
    return mockVideos;
}

function generateVideoId() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
    let result = '';
    for (let i = 0; i < 11; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
}

function displayVideos(videos) {
    const grid = document.getElementById('videoGrid');
    const filter = document.getElementById('viewFilter').value;
    
    let filteredVideos = videos;
    if (filter) {
        const maxViews = parseInt(filter);
        if (maxViews === 0) {
            filteredVideos = videos.filter(v => v.viewCount === 0);
        } else {
            filteredVideos = videos.filter(v => v.viewCount < maxViews);
        }
    }

    grid.innerHTML = filteredVideos.map(video => `
        <div class="video-item">
            <iframe src="https://www.youtube.com/embed/${video.id}" frameborder="0" allowfullscreen></iframe>
            <div class="video-title">${video.title}</div>
            <div class="video-views">${video.viewCount.toLocaleString()} views • ${video.channelName}</div>
        </div>
    `).join('');
}

document.getElementById('viewFilter').addEventListener('change', () => {
    if (allVideos.length > 0) {
        displayVideos(allVideos);
    }
});

document.getElementById('regexInput').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        generate();
    }
});

document.getElementById('patternSelect').value = '/IMG \d{4}/';
selectPattern();
generate();
    </script>
</body>
</html>